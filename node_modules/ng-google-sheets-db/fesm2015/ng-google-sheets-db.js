import { throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { InjectionToken, ɵɵdefineInjectable, ɵɵinject, Injectable, Inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';

const API_KEY = new InjectionToken('Google Sheets API key');
class GoogleSheetsDbService {
    constructor(http, apiKey) {
        this.http = http;
        this.apiKey = apiKey;
        this.defaultActiveValues = ['true', '1', 'yes'];
    }
    get(spreadsheetId, worksheetName, attributesMapping) {
        return this.getRows(spreadsheetId, worksheetName).pipe(map((rows) => this.rowsToEntries(rows).map((entry) => this.getObjectFromEntry(entry, attributesMapping))));
    }
    getActive(spreadsheetId, worksheetName, attributesMapping, isActiveColumnName = 'is_active', activeValues = null) {
        if (activeValues === null) {
            activeValues = this.defaultActiveValues;
        }
        else if (!Array.isArray(activeValues)) {
            activeValues = [activeValues];
        }
        return this.getRows(spreadsheetId, worksheetName).pipe(map((rows) => this.rowsToEntries(rows)
            .filter((obj) => activeValues.includes(obj[isActiveColumnName].toLowerCase()))
            .map((entry) => this.getObjectFromEntry(entry, attributesMapping))));
    }
    getSpreadsheetUrl(spreadsheetId, worksheetName) {
        return ('https://sheets.googleapis.com/v4/spreadsheets/' +
            spreadsheetId +
            '/values/' +
            encodeURI(worksheetName) +
            '?key=' +
            this.apiKey);
    }
    getRows(spreadsheetId, worksheetName) {
        const spreadsheetUrl = this.getSpreadsheetUrl(spreadsheetId, worksheetName);
        return this.http.get(spreadsheetUrl).pipe(map((jsonRes) => jsonRes.values), catchError(this.handleError));
    }
    rowsToEntries(rows) {
        const columns = rows[0].map(this.cleanColumnName);
        return rows.slice(1).map((row) => columns.reduce((entry, columnName, idx) => {
            entry[columnName] = row.length > idx ? row[idx] : '';
            return entry;
        }, {}));
    }
    cleanColumnName(columnName) {
        return columnName.trim();
    }
    arrayToObject(array) {
        return array.reduce((acc, cur) => {
            acc[cur] = cur;
            return acc;
        }, {});
    }
    getObjectFromEntry(entry, attributesMapping) {
        if (Array.isArray(attributesMapping)) {
            attributesMapping = this.arrayToObject(attributesMapping);
        }
        return this.getObjectFromEntryObject(entry, attributesMapping);
    }
    getObjectFromEntryObject(entry, attributesMapping, columnNamePrefix = '') {
        const obj = {};
        for (const attr in Object(attributesMapping)) {
            if (attributesMapping.hasOwnProperty(attr) &&
                !['_prefix', '_listField'].includes(attr)) {
                if (typeof attributesMapping[attr] === 'string') {
                    obj[attr] = this.getValueFromEntry(entry, columnNamePrefix + attributesMapping[attr]);
                }
                else if (typeof attributesMapping[attr] === 'object') {
                    let columnName = '';
                    if (attributesMapping[attr].hasOwnProperty('_prefix')) {
                        columnName = attributesMapping[attr]._prefix;
                    }
                    if (attributesMapping[attr]._listField) {
                        obj[attr] = this.getListFromEntry(entry, columnNamePrefix + columnName);
                    }
                    else {
                        obj[attr] = this.getObjectFromEntryObject(entry, attributesMapping[attr], columnNamePrefix + columnName);
                    }
                }
                else {
                    console.log(`Unknown type for ${attr}`);
                }
            }
        }
        return obj;
    }
    getValueFromEntry(entry, attribute) {
        attribute = this.cleanColumnName(attribute);
        if (entry.hasOwnProperty(attribute)) {
            return entry[attribute];
        }
        else {
            return null;
        }
    }
    getListFromEntry(entry, attribute) {
        const list = [];
        let i = 1;
        let curElement = this.getValueFromEntry(entry, `${attribute}${i}`);
        while (curElement) {
            list.push(curElement);
            i++;
            curElement = this.getValueFromEntry(entry, `${attribute}${i}`);
        }
        return list;
    }
    handleError(error) {
        if (error.error instanceof ErrorEvent) {
            console.error('An error occurred:', error.error.message);
        }
        else {
            console.error(`Backend returned code ${error.status}, body was: ${error.error}`);
        }
        return throwError('Something bad happened; please try again later.');
    }
}
GoogleSheetsDbService.ɵprov = ɵɵdefineInjectable({ factory: function GoogleSheetsDbService_Factory() { return new GoogleSheetsDbService(ɵɵinject(HttpClient), ɵɵinject(API_KEY)); }, token: GoogleSheetsDbService, providedIn: "root" });
GoogleSheetsDbService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
GoogleSheetsDbService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Inject, args: [API_KEY,] }] }
];

/*
 * Public API Surface of ng-google-sheets-db
 */

/**
 * Generated bundle index. Do not edit.
 */

export { API_KEY, GoogleSheetsDbService };
//# sourceMappingURL=ng-google-sheets-db.js.map
